/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#include <colors>
#include <cstrike>
#include "sodstats\include\sodstats.inc"

/*#define SILVER1 1005
#define SILVER2 1010
#define SILVER3 1020
#define SILVER4 1035
#define SILVER5 1060
#define SILVER6 1100
#define NOVA1 1150
#define NOVA2 1200
#define NOVA3 1260
#define NOVA4 1320
#define MG1 1470
#define MG2 1580
#define MGE 1700
#define DMG 1810
#define LE 1920
#define LEM 2030
#define SUPREME 2150
#define GLOBAL 2250*/

#define SILVER1 1005
#define SILVER2 1010
#define SILVER3 1020
#define SILVER4 1030
#define SILVER5 1050
#define SILVER6 1080
#define NOVA1 1110
#define NOVA2 1150
#define NOVA3 1200
#define NOVA4 1250
#define MG1 1310
#define MG2 1370
#define MGE 1440
#define DMG 1500
#define LE 1600
#define LEM 1720
#define SUPREME 1850
#define GLOBAL 2000

#define MAX_STEAMID_LENGTH     128
#define MAX_WEAPON_NAME_LENGTH 32

#define ANTISPAM_DELAY 2.0

new String:g_sql_saveplayer[]   = 
	"UPDATE players SET score = %i, kills = %i, deaths = %i, shots = %i, hits = %i, name = '%s', time_played = time_played + %i, headshots = %i, last_connect = current_timestamp WHERE steamid = '%s'"

new String:g_sql_createplayer[] = 
	"INSERT INTO players (score, kills, deaths, shots, hits, steamid, name, time_played, headshots, last_connect) VALUES (0, 0, 0, 0, 0, '%s', '%s', 0, 0, current_timestamp)"

new String:g_sqlite_createtable_players[] = 
	"CREATE TABLE IF NOT EXISTS players (rank INTEGER PRIMARY KEY AUTOINCREMENT,score int(12) NOT NULL default 0,steamid varchar(255) NOT NULL default '',kills int(12) NOT NULL default 0,deaths int(12) NOT NULL default 0,shots int(12) NOT NULL default 0,hits int(12) NOT NULL default 0,name varchar(255) NOT NULL default '',time_played int(11) NOT NULL default 0, headshots int(12) NOT NULL default 0, last_connect timestamp NOT NULL default CURRENT_TIMESTAMP);";
	
new String:g_mysql_createtable_players[] = 
	"CREATE TABLE IF NOT EXISTS players (rank INTEGER PRIMARY KEY AUTO_INCREMENT,score int(12) NOT NULL default 0,steamid varchar(255) NOT NULL default '',kills int(12) NOT NULL default 0,deaths int(12) NOT NULL default 0,shots int(12) NOT NULL default 0,hits int(12) NOT NULL default 0,name varchar(255) NOT NULL default '',time_played int(11) NOT NULL default 0, headshots int(12) NOT NULL default 0, last_connect timestamp NOT NULL default CURRENT_TIMESTAMP);";

new String:g_sql_droptable_players[] = 
	"DROP TABLE IF EXISTS 'players'; VACUUM;";

new String:g_sql_playercount[] = 
	"SELECT * FROM players";
	
new String:g_sql_addheadshots[] = 
	"ALTER TABLE players ADD COLUMN headshots int(12) NOT NULL default 0";

new String:g_sql_addtimestamp[] = 
	"ALTER TABLE players ADD COLUMN last_connect timestamp DEFAULT NULL;";

//new String:g_name[MAXPLAYERS+1][MAX_NAME_LENGTH]; you're no moar !
new String:g_safename[MAXPLAYERS+1][MAX_NAME_LENGTH];
new String:g_steamid[MAXPLAYERS+1][MAX_STEAMID_LENGTH];

new g_start_points = 1000;

#define IDENT_SIZE 16
new String:g_ident[IDENT_SIZE];

#define DBTYPE_MYSQL 1
#define DBTYPE_SQLITE 2
new g_dbtype;

new g_kills[MAXPLAYERS+1];
new g_deaths[MAXPLAYERS+1];
new g_shots[MAXPLAYERS+1];
new g_hits[MAXPLAYERS+1];
new g_score[MAXPLAYERS+1];
new g_time_joined[MAXPLAYERS+1];
new g_time_played[MAXPLAYERS+1];
new g_last_saved_time[MAXPLAYERS+1];
new g_headshots[MAXPLAYERS+1];

new g_session_kills[MAXPLAYERS+1];
new g_session_deaths[MAXPLAYERS+1];
new g_session_shots[MAXPLAYERS+1];
new g_session_hits[MAXPLAYERS+1];
new g_session_score[MAXPLAYERS+1];
new g_session_headshots[MAXPLAYERS+1];

new Float:g_fSpamPrevention[ MAXPLAYERS + 1 ];//1.0.15

new bool:g_initialized[MAXPLAYERS+1];

new g_player_count;
new g_gameid;
/*
#define DISPLAYMODE_PUBLIC  0
#define DISPLAYMODE_PRIVATE 1
#define DISPLAYMODE_CHAT    2
new g_displaymode = DISPLAYMODE_PUBLIC;
*/
new Handle:g_henabled;
new Handle:g_hstartpoints;
//new Handle:g_hdisplaymode;
new g_enabled;
new iRank[MAXPLAYERS+1] = {0,...};
new iCoin[MAXPLAYERS+1] = {0,...};


#include "sodstats\natives.sp"
#include "sodstats\css.sp"
#include "sodstats\tf2.sp"
#include "sodstats\dod.sp"
#include "sodstats\empires.sp"
#include "sodstats\defaultgame.sp"

#include "sodstats\commands\rank.sp"
#include "sodstats\commands\session.sp"
#include "sodstats\commands\statsme.sp"
#include "sodstats\commands\top.sp"

public Plugin:myinfo = 
{
	name = "Rank içerikli top10 sistemi",
	author = "ImPossibLe`",
	description = "DrK # GaminG",
	version = "2.0"
}

public OnPluginStart()
{
	int ips[4];
	char serverip[32];
	int ip = GetConVarInt(FindConVar("hostip"));
	ips[0] = (ip >> 24) & 0x000000FF;
	ips[1] = (ip >> 16) & 0x000000FF;
	ips[2] = (ip >> 8) & 0x000000FF;
	ips[3] = ip & 0x000000FF;
	
	Format(serverip, sizeof(serverip), "%d.%d.%d", ips[0], ips[1], ips[2]);
	if(StrEqual(serverip, "185.193.165") == false && ips[3] != 166)
	{
		LogError("Bu plugin ImPossibLe` tarafindan lisanslandigi icin bu serverda calistirilmadi.");
		PrintToChatAll(" \x04Bu plugin \x02ImPossibLe` \x04tarafından lisanslandığı için bu serverda çalıştırılmadı.");
		SetFailState("Plugin Copyright by ImPossibLe`");
	}
	
	decl String:error[256];
	stats_db = SQL_Connect("storage-local", false, error, sizeof(error));
	
	if(stats_db == INVALID_HANDLE)
	{
		LogError("[DrK # GaminG] Unable to connect to database (%s)", error);
		return;
	}
	
	SQL_ReadDriver(stats_db, g_ident, IDENT_SIZE);
	if(strcmp(g_ident, "mysql", false) == 0)
	{
		g_dbtype = DBTYPE_MYSQL;
	}
	else if(strcmp(g_ident, "sqlite", false) == 0)
	{
		g_dbtype = DBTYPE_SQLITE;
	}
	else
	{
		LogError("[DrK # GaminG] Invalid DB-Type");
		return;
	}
	
	SQL_LockDatabase(stats_db);
	
	if((g_dbtype == DBTYPE_MYSQL && !SQL_FastQuery(stats_db, g_mysql_createtable_players)) ||
	   (g_dbtype == DBTYPE_SQLITE && !SQL_FastQuery(stats_db, g_sqlite_createtable_players)))
	{
		LogError("[DrK # GaminG] Could not create players table.");
		return;
	}
	
	if(!SQL_FastQuery(stats_db, g_sql_addheadshots))
	{
		//LogError("[DrK # GaminG] Could not add headshots column.");
		//return;
	}
	
	if(!SQL_FastQuery(stats_db, g_sql_addtimestamp))
	{
		//LogError("[DrK # GaminG] Could not add headshots column.");
		//return;
	}
	
	g_player_count = GetPlayerCount();
	SQL_UnlockDatabase(stats_db);
	
	g_gameid = GetGameId();
	
	if(!HookEvents(g_gameid))
	{
		LogError("[DrK # GaminG] Unable to hook events.");
		return;
	}
	
	g_henabled = CreateConVar("sm_stats_enabled", "1", "Sets whether or not to record stats",FCVAR_NOTIFY, true, 0.0, true, 1.0);
	g_hstartpoints = CreateConVar("sm_stats_startpoints", "1000", "Sets the starting points for a new player",FCVAR_NOTIFY, true, 0.0, true, 10000.0);
	//g_hdisplaymode = CreateConVar("sm_stats_displaymode", "0", "Sets the stats output mode. (Public = 0, Private = 1, Chat = 2)",FCVAR_NOTIFY, true, 0.0, true, 2.0);
	HookConVarChange(g_henabled, EnabledCallback);
	HookConVarChange(g_hstartpoints, StartPointsCallback);
	//HookConVarChange(g_hdisplaymode, DisplayModeCallback);
	g_enabled = GetConVarInt(g_henabled);
	g_start_points = GetConVarInt(g_hstartpoints);
	
	if(g_henabled == INVALID_HANDLE)
	{
		LogError("[DrK # GaminG] Could not create stats_enabled cvar.");
		return;
	}
	
	RegAdminCmd("sm_drk_rank_resle", AdminCmd_ResetStats, ADMFLAG_ROOT, "Top10'u sıfırlar");
	RegAdminCmd("sm_stats_purge", AdminCmd_Purge, ADMFLAG_ROOT, "sm_stats_purge [days] - Purge players who haven't connected for [days] days.");
	RegConsoleCmd("say",      ConCmd_Say);
	RegConsoleCmd("say_team", ConCmd_Say);
	RegConsoleCmd("sm_rank", CommandRank);
	RegConsoleCmd("sm_top", CommandTop);
	
	RegAdminCmd("sm_brostest", BrosTest, ADMFLAG_ROOT, "Broş Testi");

	RegPluginLibrary("sodstats");
	
	HookEvent("player_spawn", OnPlayerSpawn);
}

public Action:BrosTest(client, args)
{
	if(args != 1)
	{
		PrintToChat(client, "Hatalı Giriş.");
		return Plugin_Handled;
	}
	else
	{
		decl String:sCoinSayisi[10];
		GetCmdArg(1,sCoinSayisi , sizeof(sCoinSayisi));
		int iCoinSayisi = StringToInt(sCoinSayisi)
		iCoin[client] = iCoinSayisi;
	}
	return Plugin_Handled;
}

public Action:CommandRank(client, args)
{
	RankYazdir(client);
	return Plugin_Continue;
}
public Action:CommandTop(client, args)
{
	PrintTop(client);
	return Plugin_Continue;
}

public Action:OnPlayerSpawn(Handle:event, /*const String:name[]*/ any:stats[], bool:dontBroadcast)
{
	new i = GetClientOfUserId(GetEventInt(event, "userid"));
	if(g_score[i] + 1000 < SILVER2)
		iRank[i] = 1; // SILVER1
	else if(g_score[i] + 1000 >= SILVER2 && g_score[i] + 1000 < SILVER3)
		iRank[i] = 2; // SILVER2
	else if(g_score[i] + 1000 >= SILVER3 && g_score[i] + 1000 < SILVER4)
		iRank[i] = 3; // SILVER3
	else if(g_score[i] + 1000 >= SILVER4 && g_score[i] + 1000 < SILVER5)
		iRank[i] = 4; // SILVER4
	else if(g_score[i] + 1000 >= SILVER5 && g_score[i] + 1000 < SILVER6)
		iRank[i] = 5; // SILVER5
	else if(g_score[i] + 1000 >= SILVER6 && g_score[i] + 1000 < NOVA1)
		iRank[i] = 6; // SILVER6
	else if(g_score[i] + 1000 >= NOVA1 && g_score[i] + 1000 < NOVA2)
		iRank[i] = 7; // NOVA1
	else if(g_score[i] + 1000 >= NOVA2 && g_score[i] + 1000 < NOVA3)
		iRank[i] = 8; // NOVA2
	else if(g_score[i] + 1000 >= NOVA3 && g_score[i] + 1000 < NOVA4)
		iRank[i] = 9; // NOVA3
	else if(g_score[i] + 1000 >= NOVA4 && g_score[i] + 1000 < MG1)
		iRank[i] = 10; // NOVA4
	else if(g_score[i] + 1000 >= MG1 && g_score[i] + 1000 < MG2)
		iRank[i] = 11; // MG1
	else if(g_score[i] + 1000 >= MG2 && g_score[i] + 1000 < MGE)
		iRank[i] = 12; // MG2
	else if(g_score[i] + 1000 >= MGE && g_score[i] + 1000 < DMG)
		iRank[i] = 13; // MGE
	else if(g_score[i] + 1000 >= DMG && g_score[i] + 1000 < LE)
		iRank[i] = 14; // DMG
	else if(g_score[i] + 1000 >= LE && g_score[i] + 1000 < LEM)
		iRank[i] = 15; // LE
	else if(g_score[i] + 1000 >= LEM && g_score[i] + 1000 < SUPREME)
		iRank[i] = 16; // LEM
	else if(g_score[i] + 1000 >= SUPREME && g_score[i] + 1000 < GLOBAL)
		iRank[i] = 17; // SUPREME
	else if(g_score[i] + 1000 >= GLOBAL)
		iRank[i] = 18; // GLOBAL
	
	decl String:authid[32];
	GetClientAuthString(i, authid, sizeof(authid));
	
	decl String:sClientName[40];
	GetClientName(i, sClientName, sizeof(sClientName));
	
	if(StrEqual(authid, "STEAM_1:1:104585403", false)) // UĞUR ÖZEL GLOBAL
	{
		iRank[i] = 18;
		if(iCoin[i] == 0)
		{
			iCoin[i] = 6002;
			//CPrintToChatAll(" \x02[DrK # GaminG] \x10%s\x0C Yetkilerinden dolayı broş aldı.", sClientName);
		}
	}
	else if(StrEqual(authid, "STEAM_1:1:150784409", false)) // MESUT ABİ ÖZEL GLOBAL
	{
		iRank[i] = 18;
		if(iCoin[i] == 0)
		{
			iCoin[i] = 6002;
			//CPrintToChatAll(" \x02[DrK # GaminG] \x10%s\x0C Yetkilerinden dolayı broş aldı.", sClientName);
		}
	}
	else if(StrEqual(authid, "STEAM_1:1:160468232", false)) // Cenk - Asker
	{
		iRank[i] = 18;
	}
	else if(StrEqual(authid, "STEAM_1:1:102388192", false)) // Yavuz
	{
		iRank[i] = 15;
	}
	else if(StrEqual(authid, "STEAM_1:1:81641664", false)) // Tavuk
	{
		iRank[i] = 16;
	}
	else if(StrEqual(authid, "STEAM_1:0:178072451", false)) // Benjii +3
	{
		if(iRank[i] <= 13)
			iRank[i] += 5;
		else
			iRank[i] = 18;
	}
	else if(StrEqual(authid, "STEAM_1:1:101340186", false)) // Murat +4
	{
		if(iRank[i] <= 14)
			iRank[i] += 4;
		else
			iRank[i] = 18;
	}	
	else if(StrEqual(authid, "STEAM_1:1:91996789", false))
	{
		iRank[i] = 1;
	}
	else if(StrEqual(authid, "STEAM_1:0:47889108", false)) // İBO ÖZEL VİCTORY
	{
		iCoin[i] = 6006;
	}
	else if(StrEqual(authid, "STEAM_1:1:54499769", false)) // CAN(USTAKOMUTAN) ÖZEL VİCTORY
	{
		iCoin[i] = 6006;
	}
	else if(IsPlayerGenericAdmin(i))
	{
		if(iCoin[i] == 0)
		{
			iCoin[i] = 6010;
			//CPrintToChatAll(" \x02[DrK # GaminG] \x10%s\x0C Yetkilerinden dolayı broş aldı.", sClientName);
		}
	}
	else if(CS_GetMVPCount(i) > 0)
	{
		if(iCoin[i] == 0)
		{	
			new coinler[45] = {874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,1001,1002,1003,1013,1014,1015,1024,1025,1026,1028,1029,1030,1316,1317,1318}
			iCoin[i] = coinler[GetRandomInt(0, 44)];
			CPrintToChatAll(" \x02[DrK # GaminG] \x10%s\x0C EDO kazandığı için broş aldı.", sClientName);
		}
	}
	else if(CS_GetMVPCount(i) == 0)
	{
		iCoin[i] = 0;
	}
	
	//PrintToChatAll("Test: %s", authid);
}

bool:IsPlayerGenericAdmin(client)
{
    if (CheckCommandAccess(client, "generic_admin", ADMFLAG_GENERIC, false))
    {
        return true;
    }
    return false;
}

public OnMapStart()
{
	new iIndex = FindEntityByClassname(MaxClients+1, "cs_player_manager");
	if (iIndex == -1) {
		SetFailState("Unable to find cs_player_manager entity");
	}
	SDKHook(iIndex, SDKHook_ThinkPost, Hook_OnThinkPost);
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if ((buttons & IN_SCORE) == IN_SCORE) {
		new Handle:hBuffer = StartMessageOne("ServerRankRevealAll", client);
		if (hBuffer == INVALID_HANDLE) {
			PrintToChat(client, " \x04[DrK # GaminG] \x02Hatalı komut!");
		}
		else {
			EndMessage();
		}
	}
	return Plugin_Continue;
}

public Hook_OnThinkPost(iEnt) {
	static iRankOffset = -1;
	if (iRankOffset == -1) {
		iRankOffset = FindSendPropInfo("CCSPlayerResource", "m_iCompetitiveRanking");
	}
	SetEntDataArray(iEnt, iRankOffset, iRank, MAXPLAYERS+1, _, true);
	
	static iCoinOffset = -1;
	if (iCoinOffset == -1) {
		iCoinOffset = FindSendPropInfo("CCSPlayerResource", "m_nActiveCoinRank");
	}
	SetEntDataArray(iEnt, iCoinOffset, iCoin, MAXPLAYERS+1, _, true);
}


public OnClientDisconnect(userid)
{
	iCoin[userid] = 0;
	iRank[userid] = 0;
	// Ignore bot disconnects
	if(g_initialized[userid] == true)
	{
		// Save the player stats
		SavePlayer(userid);
		// and uninitialize them
		g_initialized[userid] = false;
	}
	g_fSpamPrevention[ userid ] = 0.0;
}

public OnClientAuthorized(client, const String:steamid[])
{
	//new client = GetClientOfUserId(userid);
	// Don't load bot stats or initialize them
	if(!IsFakeClient(client))
	{
		strcopy(g_steamid[client], sizeof(g_steamid[]), steamid);
		
		decl String:szName[MAX_NAME_LENGTH];
		GetClientName(client, szName, sizeof(szName));
		SQL_EscapeString(stats_db, szName, g_safename[client], sizeof(g_safename[]));
		
		GetPlayerBySteamId(steamid, LoadPlayerCallback, client);
	}
}

public EnabledCallback(Handle:convar, const String:oldValue[], const String:newValue[])
{
	if(strcmp(newValue, "0") == 0)
		g_enabled = 0;
	else
		g_enabled = 1;
}

public StartPointsCallback(Handle:convar, const String:oldValue[], const String:newValue[])
{
	g_start_points = StringToInt(newValue);
}
/*
public DisplayModeCallback(Handle:convar, const String:oldValue[], const String:newValue[])
{
	g_displaymode = StringToInt(newValue);
}*/

public Action:ConCmd_Say(userid, args)
{
	int koruma;
	koruma = GetTime();
	if(koruma + 3 > GetTime())
		return Plugin_Continue;
	if(!userid || g_enabled == 0)
		return Plugin_Continue;
	
	new client = GetClientOfUserId(userid);
	
	decl String:text[192];		// from rockthevote.sp
	if(!GetCmdArgString(text, sizeof(text)))
		return Plugin_Continue;
	
	new startidx = 0;
	
	// Strip quotes from argument
	if(text[strlen(text)-1] == '"')
	{
		text[strlen(text)-1] = '\0';
		startidx = 1;
	}
	
	//Anti-spam
	if ( g_fSpamPrevention[ userid ] + ANTISPAM_DELAY > GetGameTime() )
		return Plugin_Continue;
	
	g_fSpamPrevention[ userid ] = GetGameTime();
	
	if(strcmp(text[startidx], "rank", false) == 0)
	{
		//PrintRankToAll(userid);
		RankYazdir(client);
		return Plugin_Continue;
	}
	if(strcmp(text[startidx], "top", false) == 0 || 
			strcmp(text[startidx], "top10", false) == 0)
	{
		PrintTop(client);
	}
	
	if(g_gameid != ID_EMPIRES)
	{
		if(strcmp(text[startidx], "statsme", false) == 0)
		{
			PrintStats(client);
		}
		else if(strcmp(text[startidx], "session", false) == 0)
		{
			PrintSession(client);
		}
	}
	
	return Plugin_Continue;
}

public LoadPlayerCallback(const String:name[], const String:steamid[], any:stats[], any:data, error)
{
	new client = data;
	
	g_session_deaths[client]    = 0;
	g_session_kills[client]     = 0;
	g_session_hits[client]      = 0;
	g_session_shots[client]     = 0;
	g_session_score[client]     = 0;
	g_session_headshots[client] = 0;
	
	g_time_joined[client] = GetTime();
	g_last_saved_time[client] = g_time_joined[client];
	
	if(error == ERROR_PLAYER_NOT_FOUND)
	{
		CreatePlayer(client, g_steamid[client]);
		return;
	}
	
	strcopy(g_safename[client], MAX_NAME_LENGTH, name);
	g_kills[client]       = stats[STAT_KILLS];
	g_deaths[client]      = stats[STAT_DEATHS];
	g_shots[client]       = stats[STAT_SHOTS];
	g_hits[client]        = stats[STAT_HITS];
	g_score[client]       = stats[STAT_SCORE];
	g_time_played[client] = stats[STAT_TIME_PLAYED];
	g_headshots[client]   = stats[STAT_HEADSHOTS];
	
	g_initialized[client] = true;
}

public Action:AdminCmd_ResetStats(client, args)
{
	ResetStats();
	decl String:mapName[64];
	GetCurrentMap(mapName, sizeof(mapName));
	ServerCommand("changelevel %s", mapName);
	
	return Plugin_Handled;
}

public Action:AdminCmd_Purge(client, args)
{
	new argCount = GetCmdArgs();
	
	if(argCount != 1)
	{
		PrintToConsole(client, "SoD-Stats: Invalid number of arguments for command 'sm_stats_purge'");
		return Plugin_Handled;
	}
	
	decl String:svDays[192];
	if(!GetCmdArg(1, svDays, 192))
	{
		PrintToConsole(client, "SoD-Stats: Invalid arguments for sm_stats_purge.");
		return Plugin_Handled;
	}
	
	new days = StringToInt(svDays);
	if(days <= 0)
	{
		PrintToConsole(client, "SoD-Stats: Invalid number of days.");
		return Plugin_Handled;
	}

	decl String:query[128];
	
	
	switch(g_dbtype)
	{
		case DBTYPE_MYSQL: 
			Format(query, 128, "DELETE FROM players WHERE last_connect < current_timestamp - interval %i day;", days);
		case DBTYPE_SQLITE: 
			Format(query, 128, "DELETE FROM players WHERE last_connect < datetime('now', '-%i days');", days);
	}
	
	SQL_TQuery(stats_db, SQL_PurgeCallback, query, client);
	
	return Plugin_Handled;
}

public SQL_PurgeCallback(Handle:owner, Handle:hndl, const String:error[], any:data)
{
	if(hndl == INVALID_HANDLE)
	{
		LogError("SQL_PurgeCallback: Invalid query (%s).", error);
	}
	else
	{
		PrintToConsole(data, "SoD-Stats: Purge successful");
	}
}

GetPlayerCount()
{
	new Handle:hquery = SQL_Query(stats_db, g_sql_playercount);
	if(hquery == INVALID_HANDLE)
	{
		LogError("[SoD-Stats] Error getting player count.");
		return 0;
	}
	new rows = SQL_GetRowCount(hquery);
	CloseHandle(hquery);
	
	return rows;
}

GetGameId()
{
	new String:fldr[64];
	
	GetGameFolderName(fldr, sizeof(fldr));
	
	if(strcmp(fldr, "tf") == 0)
	{
		return ID_TF2;
	}
	else if(StrEqual(fldr, "cstrike") || StrEqual(fldr, "csgo"))
	{
		return ID_CSS;
	}
	else if(strcmp(fldr, "dod") == 0)
	{
		return ID_DODS;
	}
	else if(strcmp(fldr, "FortressForever") == 0)
	{
		return ID_FORTRESSFOREVER;
	}
	else if(strcmp(fldr, DIR_EMPIRES) == 0)
	{
		return ID_EMPIRES;
	}
	return ID_DEFAULTGAME;
}

bool:HookEvents(gameid)
{
	switch(gameid)
	{
		case ID_CSS:
			HookEventsCSS();
		case ID_TF2: 
			HookEventsTF2();
		case ID_DODS: 
			HookEventsDOD();
		case ID_FORTRESSFOREVER: 
			HookEventsTF2();
		case ID_EMPIRES: 
			HookEventsEmpires();
		case ID_DEFAULTGAME: 
			HookEventsDefault();
		default: 
		{
			LogError("[DrK # GaminG] Invalid gameid (%i).", g_gameid);
			return false;
		}
	}
	return true;
}

SavePlayer(const userid)
{
	if(stats_db == INVALID_HANDLE || g_enabled == 0)
		return false;
	
	new String:name[MAX_NAME_LENGTH];
	new String:safe_name[MAX_NAME_LENGTH * 2 + 1]; //I guess there was a reason Frozen decided to not use the global one :?
	
	GetClientName(userid, name, sizeof(name));
	SQL_EscapeString(stats_db, name, safe_name, sizeof(safe_name));
	
	// save player here
	decl String:query[512];
	new time = GetTime();
	Format(query, sizeof(query), g_sql_saveplayer, g_score[userid], 
												   g_kills[userid],
												   g_deaths[userid], 
												   g_shots[userid], 
												   g_hits[userid], 
												   safe_name, 
												   time - g_last_saved_time[userid], 
												   g_headshots[userid], 
												   g_steamid[userid]);
	g_last_saved_time[userid] = time;
	SQL_TQuery(stats_db, SQL_SavePlayerCallback, query);
	return 0;
}

public SQL_SavePlayerCallback(Handle:owner, Handle:hndl, const String:error[], any:data)
{
	if(hndl == INVALID_HANDLE)
		LogError("[DrK # GaminG] Error saving player (%s)", error);
}

CreatePlayer(const userid, const String:steamid[])
{
	decl String:query[256];
	new String:name[MAX_NAME_LENGTH];
	new String:safe_name[MAX_NAME_LENGTH * 2 + 1];
	
	GetClientName(userid, name, sizeof(name));
	SQL_EscapeString(stats_db, name, safe_name, sizeof(safe_name));
	Format(query, sizeof(query), g_sql_createplayer, steamid, safe_name);

	SQL_TQuery(stats_db, SQL_CreatePlayerCallback, query, userid);
}

public SQL_CreatePlayerCallback(Handle:owner, Handle:hndl, const String:error[], any:data)
{
	new client = data;
	
	if(hndl != INVALID_HANDLE)
	{
		if(IsClientConnected(client))  // fix
		{
			decl String:szName[MAX_NAME_LENGTH];
			GetClientName(client, szName, sizeof(szName));
			SQL_EscapeString(stats_db, szName, g_safename[client], sizeof(g_safename[]));
		}
		
		g_kills[client]       = 0;
		g_deaths[client]      = 0;
		g_shots[client]       = 0;
		g_hits[client]        = 0;
		g_score[client]       = 0;
		g_time_played[client] = 0;
		g_headshots[client]   = 0;
	
		g_session_deaths[client]    = 0;
		g_session_kills[client]     = 0;
		g_session_hits[client]      = 0;
		g_session_shots[client]     = 0;
		g_session_score[client]     = 0;
		g_session_headshots[client] = 0;
		
		g_time_joined[client] = GetTime();
		g_initialized[client] = true;
		g_player_count++;
	}
	else
		LogError("[SoD-Stats] SQL_CreatePlayerCallback failure: %s", error);
}
